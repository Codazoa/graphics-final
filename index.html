<!DOCTYPE html>
<html lang="en">
<head>
    <title>cs442-graphics-engine</title>
    <style media="screen">
        #the-canvas {border: 1px solid darkblue}

        .fov-range,
        .camera-speed {
            padding-left: 30px;
            float: left;
        }

    </style>
</head>
<body>
    <canvas id="the-canvas" width="1280" height="720"></canvas>

    <script src="lib.js"></script>
    <script src="matrix.js"></script>
    <script src="vector.js"></script>
    <script src="mesh.js"></script>
    <script src="listener.js"></script>
    <script src="camera.js"></script>
    <script src="texture.js"></script>
    <script src="shaders.js"></script>
    <script src="material.js"></script>
    <script src="scene.js"></script>

    <script>
        let this_mesh;

        // camera movements
        const FORWARD = 0;
        const LEFT = 1;
        const BACKWARD = 2;
        const RIGHT = 3;
        const UP = 4;
        const DOWN = 5;

        
        const DESIRED_TICK_RATE = 60;
        const DESIRED_MSPT = 1000 / DESIRED_TICK_RATE;
        const ASPECT_RATIO = 16/9; // 16:9 aspect ratio
        let FOV = 90; // FOV in degrees (is converted later)
        const NEAR = 0.1; // distance to near plane
        const FAR = 100; // distance to far plane
        
        // set rotation speeds turns/second
        let ROTATION_SPEED_XY = 0.0; 
        let ROTATION_SPEED_XZ = 0.0;
        let ROTATION_SPEED_YZ = 0.0;
        
        // set translation amounts
        let TRANSLATION_X = 0;
        let TRANSLATION_Y = 0;
        let TRANSLATION_Z = 0;
        
        // set rotation amounts
        let rotation_amnt_xy = 0.0;
        let rotation_amnt_xz = 0.0;
        let rotation_amnt_yz = 0.0;
        
        // camera control speeds
        let CAMERA_SPEED = 0.002

        // light settings
        // const ambient = 0.25;
        // const diffuse = 1.0;
        // const specular = 2.0;
        // const shininess = 4.0;

        const sun_dir = new Vec4( 0.0, 1.0, 0.0, 0.0 );
        const sun_color = new Vec4( 1.0, 1.0, 1.0, 1.0 );

        const point_light_dir = new Vec4( 1.0, 0.0, 0.0, 0.0 );
        const point_light_color = new Vec4( 1.0, 0.0, 0.0, 1.0 );
        
        let time_delta = 0.0;
        let last_update = performance.now();       
        
        let canvas = document.getElementById("the-canvas");
        /** @type {WebGLRenderingContext} */
        let gl = canvas.getContext('webgl2');
        
        // let view = new Camera( 0, 0, 2 );
        let camera = new Camera( 0, 0, -2, CAMERA_SPEED );
        let view = camera.get_view();
        let perspective = new Mat4();
        let modelview = new Mat4();
        
        // compile shaders and activate the shader program
        let shader_program = create_compile_and_link_program( gl, vertex_source, fragment_source );
        gl.useProgram( shader_program );
        
        // setting various render settings
        set_render_params( gl );     
        /*
        // set the mesh to use
        // Mesh.from_obj_file( gl, "test_meshes/teapot.obj", shader_program, get_mesh)
        get_mesh( Mesh.make_uv_sphere(gl, shader_program, 16, null) );
        
        // texture stuff
        let tex = gl.createTexture();

        gl.bindTexture( gl.TEXTURE_2D, tex );
        set_uniform_scalar( gl, shader_program, 'mat_ambient', ambient );
        set_uniform_scalar( gl, shader_program, 'mat_diffuse', diffuse ); 
        set_uniform_scalar( gl, shader_program, 'mat_specular', specular );
        set_uniform_scalar( gl, shader_program, 'mat_shininess', shininess );
        set_uniform_vec3_array( gl, shader_program, 'camera_pos', [camera.position.x, camera.position.y, camera.position.z]);
        set_uniform_vec3_array( gl, shader_program, 'sun_dir', [sun_dir.x, sun_dir.y, sun_dir.z] );
        set_uniform_vec3_array( gl, shader_program, 'sun_color', [sun_color.x, sun_color.y, sun_color.z] );

        set_uniform_vec3_array( gl, shader_program, 'point_light_dir', [point_light_dir.x, point_light_dir.y, point_light_dir.z] );
        set_uniform_vec3_array( gl, shader_program, 'point_light_color', [point_light_color.x, point_light_color.y, point_light_color.z] );

        gl.texImage2D( 
            gl.TEXTURE_2D, 0, gl.RGBA,
            256, 256, 0,
            gl.RGBA, gl.UNSIGNED_BYTE,
            xor_texture(256)
        );
        gl.generateMipmap( gl.TEXTURE_2D );

        // set up image
        let image = new Image();
        image.onload = function () {
            gl.bindTexture( gl.TEXTURE_2D, tex );
            gl.texImage2D( 
                gl.TEXTURE_2D, 0, gl.RGBA,
                gl.RGBA, gl.UNSIGNED_BYTE,
                image
            );
            gl.generateMipmap( gl.TEXTURE_2D );
        };

        image.src = 'tex/metal_scale.png';

        let listener = Keys.start_listening();
        
        function get_mesh( mesh ) {
            this_mesh = mesh;
        }
        */

        set_uniform_vec3_array( gl, shader_program, 'camera_pos', [camera.position.x, camera.position.y, camera.position.z]);
        set_uniform_vec3_array( gl, shader_program, 'sun_dir', [sun_dir.x, sun_dir.y, sun_dir.z] );
        set_uniform_vec3_array( gl, shader_program, 'sun_color', [sun_color.x, sun_color.y, sun_color.z] );

        // set_uniform_vec3_array( gl, shader_program, 'point_light_dir', [point_light_dir.x, point_light_dir.y, point_light_dir.z] );
        // set_uniform_vec3_array( gl, shader_program, 'point_light_color', [point_light_color.x, point_light_color.y, point_light_color.z] );

        let listener = Keys.start_listening();

        let key_bindings = {
            "KeyW": function() { camera.pan(FORWARD) },
            "KeyA": function() { camera.pan(LEFT) },
            "KeyS": function() { camera.pan(BACKWARD) },
            "KeyD": function() { camera.pan(RIGHT) },
            "Space": function() { camera.pan(UP) },
            "KeyC": function() { camera.pan(DOWN) },
            "KeyQ": function() { camera.roll(-1) },
            "KeyE": function() { camera.roll(1) },
            "ArrowUp": function() { camera.pitch(1) },
            "ArrowLeft": function() { camera.yaw(-1) },
            "ArrowDown": function() { camera.pitch(-1) },
            "ArrowRight": function() { camera.yaw(1) }
        }


        //set up the scene
        //sun
        // let sun_mat = new Material(gl, 1, 0.0, 0.0, 1.0, 'tex/sun/sun_col.jpg');
        let sun_mat = new Material(gl, 0.25, 1.0, 2.0, 4.0, 'tex/sun/sun_col.jpg');
        let sun_mesh = Mesh.uv_sphere(gl, shader_program, 24, sun_mat);

        //earth
        let earth_mat = new Material(gl, 0.25, 1.0, 2.0, 4.0, 'tex/earth/earth_col.jpg');
        let earth_mesh = Mesh.uv_sphere(gl, shader_program, 24, earth_mat);

        //moon
        let moon_mat = new Material(gl, 0.25, 1.0, 0.5, 1, 'tex/moon/moon_col.jpg');
        let moon_mesh = Mesh.uv_sphere(gl, shader_program, 24, moon_mat);

        let scene = new Scene();
        
        let root = scene.root.create_child_node(0, 0, 0,     1, 1, 1,    1, 1, 1, null);
        
        let sun = root.create_child_node(0, 0, 0,     1, 1, 1,    1, 1, 1, sun_mesh);
        let sun_light = sun.create_child_node(1,1,1,     1, 1, 1,    1, 1, 1, new NodeLight(1.0, 0.8, 0.0, false));
        

        let earth_arm = sun.create_child_node(0, 0, 0,     1, 1, 1,    1, 1, 1, null);
        let earth_pos = earth_arm.create_child_node(3, 0, 0,    1, 1, 0.95,   .5, .5, .5, null);
        let earth = earth_pos.create_child_node(0, 0, 0,     1, 1, 1,    1, 1, 1, earth_mesh);
        let bitchlight = earth_pos.create_child_node(1, 0, 0,     1, 1, 1,    1, 1, 1, new NodeLight(0.6, 0.2, 0.8, false));

        let moon_arm = earth_pos.create_child_node(0, 0, 0,     1, 1, 1,    1, 1, 1, null);
        let moon = moon_arm.create_child_node(3, 0, 0,     1, 1, 1,    0.25, 0.25, 0.25, moon_mesh);


        gl.clearColor(0.05 , 0.05, 0.05, 1);
        gl.enable(gl.DEPTH_TEST);
        gl.clear(gl.COLOR_BUFFER_BIT);
        
        setInterval( update, DESIRED_MSPT, performance.now() );
        render(performance.now());

        const DELTA_T = 1/DESIRED_TICK_RATE;
        function update() {
            
            // update camera
            listener.keys_down_list().forEach( key => {
                if( key in key_bindings ) {
                    key_bindings[key]();
                }
            });

            set_uniform_vec3_array( gl, shader_program, 'camera_pos', [camera.position.x, camera.position.y, camera.position.z]);
                
            // get new rotations
            rotation_amnt_xy += ROTATION_SPEED_XY / DESIRED_TICK_RATE;
            rotation_amnt_xz += ROTATION_SPEED_XZ / DESIRED_TICK_RATE;
            rotation_amnt_yz += ROTATION_SPEED_YZ / DESIRED_TICK_RATE; 
            
            // keep rotations betweeen 0 and 1
            rotation_amnt_xy %= 1.0;
            rotation_amnt_xz %= 1.0;
            rotation_amnt_yz %= 1.0; 
            
            // create the 3 rotation matrices
            let rot_xy = Mat4.rotation_xy( rotation_amnt_xy );
            let rot_xz = Mat4.rotation_xz( rotation_amnt_xz );
            let rot_yz = Mat4.rotation_yz( rotation_amnt_yz );
            
            perspective = Mat4.perspective( FOV, ASPECT_RATIO, NEAR, FAR );
            
            // move the mesh away from the camera
            translation = Mat4.translation( TRANSLATION_X, TRANSLATION_Y, TRANSLATION_Z );
            
            // multiply the rotations and translations to a final model
            model = rot_yz.mul( rot_xz.mul( rot_xy ) );
            model = translation.mul( model );
            
            earth_pos.add_yaw(10 * DELTA_T);
            earth_arm.add_roll(97 * DELTA_T);

            let jobs = [];
            let lights = [];
            scene.generate_render_batch(jobs, lights);

            view = camera.get_view();

            set_uniform_matrix4(gl, shader_program, "view", view.data);
            set_uniform_matrix4(gl, shader_program, "perspective", perspective.data);

            // modelview = view.mul( model );
            
            // modelview = perspective.mul( modelview )
        }
        
        // initializing render function
        function render( now ){
            
            
            // clear screen
            gl.clear( gl.COLOR_BUFFER_BIT );
            
            let jobs = [];
            let lights = [];
            scene.generate_render_batch(jobs, lights);

           
            for (let i = 0; i < jobs.length; i++) {
                if (jobs[i].mesh != null){
                    // console.log('mesh should render');
                    
                    jobs[i].mesh.render(gl);
                    jobs[i].mesh.material.bind(gl, shader_program);
                }  else {
                    // console.log('mesh not loaded')
                };
                
                set_uniform_matrix4(gl, shader_program, "model", jobs[i].matrix.data);
            }
            let light_locs = [];
            let light_colors = [];
            for (let i = 0; i < 8; i++) {

                if (lights[i] != null){
                    light_locs[i] = [lights[i].loc.x, lights[i].loc.y, lights[i].loc.z];
                    light_colors[i] = [lights[i].color.r, lights[i].color.g, lights[i].color.b];
                } else {
                    // break;
                    light_locs[i] = [0, 0, 0];
                    light_colors[i] = [0, 0, 0];
                }
                set_uniform_vec3_array(gl, shader_program, "point_light_dir["+i.toString()+"]",  light_locs[i]);
                set_uniform_vec3_array(gl, shader_program, "point_light_color["+i.toString()+"]", light_colors[i]);
            }
            // set_uniform_vec3_array(gl, shader_program, "point_light_dir["+i.toString()+"]",  light_locs[0]);
            // set_uniform_vec3_array(gl, shader_program, "point_light_color["+i.toString()+"]", light_colors[0]);

            requestAnimationFrame( render );
        }
        
        // requestAnimationFrame( render );
        
        function updateFOV() {
            let x = document.getElementById("fov").value;
            FOV = x;
        }

        function updateCameraSpeed() {
            let speed = document.getElementById("cam-speed").value;
            camera.speed = speed / 5000

        }
            
    </script>

    <!-- Creating the sliders below the canvas -->
    <div class="slider-container">
        <div class="fov-range">
            <label for="fov-change">FOV</label>
            <div class="slider">
                <label for="fov" class="float-left"></label>
                <input type="number" id="fov" min="1" max="170" value="90" oninput="updateFOV()">
            </div>
        </div>
        
        <div class="camera-speed">
            <label for="camera-speed">Camera Speed</label>
            <div class="numbers">
                <label for="speed" class="float-left"></label>
                <input type="number" id="cam-speed" min="0" max="100" name="speed" value="10" oninput="updateCameraSpeed()">
            </div>

        </div>
    </div>
    
</body>
</html>